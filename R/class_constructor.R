
check_pheno_data <- function(x, id_prefix) {

  # Check that Injection order is included
  if (!"Injection_order" %in% colnames(x)) {
    stop('"Injection_order" not found for the samples')
  }
  # Injection order should be unique
  if (length(unique(x$Injection_order)) != nrow(x)) {
    stop("Injection_order is not unique")
  }
  # If Sample_ID is not provided explicitly, it will be created
  if (!"Sample_ID" %in% colnames(x)) {
    x$Sample_ID <- paste0(id_prefix, x$Injection_order)
  } else {
    # Add a running index to all "QC" identifiers
    x$Sample_ID <- as.character(x$Sample_ID)
    x$Sample_ID[x$Sample_ID == "QC"] <- paste0("QC_", seq_len(sum(x$Sample_ID == "QC")))
    # After this, the Sample IDs should be unique
    if (length(unique(x$Sample_ID)) != nrow(x)) {
      stop("Sample_ID is not unique")
    }
  }

  x <- best_classes(x)
  rownames(x) <- x$Sample_ID
  x <- as.data.frame(dplyr::select(x, Sample_ID, dplyr::everything()))
  x
}


check_position <- function(x, cc, cr) {
  condition <- (is.na(x[cr - 1, cc - 1])) &
    (is.numeric(type.convert(x[cr + 1, cc + 1]))) &
    (!is.na(x[cr, cc]))
  if (!condition) {
    stop("The corner row and column coordinates seem to be incorrect!")
  }

}


#' Read formatted Excel files
#'
#'
#' Reads data from an Excel file of the following format:
#' \itemize{
#'   \item Left side of the sheet contains information about the features, size features x feature info columns
#'   \item Top part contains sample information, size sample info variables x samples
#'   \item The middle contains the actual abundances, size features x samples
#' } See the vignette for more information.
#' This function separates the three parts from the file, and returns them in a list
#'
#' @param file path to the Excel file
#' @param sheet the sheet number or name
#' @param corner_row interger, the bottom row of sample information, usually contains data file names and feature info column names
#' @param corner_column integer or character, the corresponding column number or the column name (letter) in Excel
#' @param id_prefix character, prefix for  autogenerated sample IDs, see Details
#' @param split_by character vector, in the case where all the modes are in the same Excel file, the column names of feature data used to separate the modes (usually Mode and Column)
#' @param name in the case where the Excel file only contains one mode, the name of the mode, such as "Hilic_neg"
#'
#' @return list of three data frames:
#' \itemize{
#'   \item assay_data: the actual abundances, size features x samples
#'   \item pheno_data: sample information, size sample info variables x samples
#'   \item feature_data: information about the features, size features x feature info columns
#' }
#'
#' @details Only specify one of \code{split_by} and \code{name}. The feature data returned will contain a column
#' named "Split", which is used to separate features from different modes. Unless a column named "Feature_ID"
#' is found in the file, a feature ID will be generated based on the value of "Split", mass and retention time.
#' The function will try to find columns for mass and retention time by looking at a few common alternatives,
#' and throw an error if no matching column is found. Sample information needs to contain a row called "Injection_order",
#' and the values need to be unique. In addition, a possible sample identifier row needs to be named "Sample_ID",
#' and the values need to be unique, with an exception of QC samples: if there are any "QC" identifiers, they will
#' be replaced with "QC_1", "QC_2" and so on. If a "Sample_ID" row is not found, it will be created using the \code{id_prefix}
#' and injection order.
#'
#'
#' @importFrom magrittr "%>%"
#'
#' @export
read_from_excel <- function(file, sheet, corner_row, corner_column, id_prefix = "ID_", split_by = NULL, name = NULL) {

  if (is.null(split_by) & is.null(name)) {
    stop("Etiher namr or split_by needs to be defined, see documentation")
  } else if ((!is.null(split_by)) & (!is.null(name))) {
    stop("Only define split_by OR name, see documentation")
  }

  dada <- openxlsx::read.xlsx(file, sheet, colNames = FALSE)

  # Define excel column order A-Z, AA - ZZ
  combinations <- expand.grid(LETTERS, LETTERS)
  excel_columns <- c(LETTERS, paste0(combinations$Var2, combinations$Var1))

  # Column can be given as a character
  cc <- ifelse(is.character(corner_column),
               which(excel_columns == corner_column),
               corner_column)
  cr <- corner_row

  check_position(dada, cc, cr)

  # Extract sample information
  pheno_data <- as.data.frame(t(dada[1:cr, (cc+1):ncol(dada)]), stringsAsFactors = FALSE)
  colnames(pheno_data) <- gsub(" ", "_", c(dada[1:(cr-1), cc], "Datafile"))

  # If a single mode is given, datafile will indicate the mode
  if (!is.null(name)) {
    colnames(pheno_data)[ncol(pheno_data)] <- paste0(name, "_Datafile")
  }

  pheno_data <- check_pheno_data(x = pheno_data, id_prefix = id_prefix)

  # Exctract feature information
  feature_data <- dada[(cr+1):nrow(dada), 1:cc]
  colnames(feature_data) <- dada[cr, 1:cc]

  # If the file only contains one mode, add the mode name as Split column
  if (!is.null(name)) {
    feature_data$Split <- name
    split_by <- "Split"
  } else { # Multiple modes in the file, create Split column to separate modes
    feature_data <- feature_data %>%
      tidyr::unite("Split", split_by, remove = FALSE)
  }

  # Create feature ID if necessary
  if (!"Feature_ID" %in% colnames(feature_data)){
    feature_data <- name_features(feature_data = feature_data)
  }
  # Reorganise columns and add Flag column
  feature_data <- feature_data %>%
    dplyr::select(Feature_ID, Split, dplyr::everything()) %>%
    best_classes() %>%
    dplyr::mutate_if(is.factor, as.character) %>%
    dplyr:: mutate(Flag = NA_character_)
  rownames(feature_data) <- feature_data$Feature_ID

  # Extract LC-MS measurements as matrix
  assay_data <- dada[(cr+1):nrow(dada), (cc+1):ncol(dada)] %>%
    apply(2, as.numeric)
  rownames(assay_data) <- rownames(feature_data)
  colnames(assay_data) <- rownames(pheno_data)

  return(list(assay_data = assay_data, pheno_data = pheno_data, feature_data = feature_data))
}
# Combines mode name, mass and retention time to create a Feature ID
#' @importFrom magrittr "%>%"
name_features <- function(feature_data) {

  # Find mass and retention time columns
  mz_tags <- c("mass", "average mz", "average.mz")
  rt_tags <-  c("retention time", "retentiontime", "average rt[(]min[)]",
                "^rt$")

  mz_col <- NULL
  for (tag in mz_tags) {
    hits <- grepl(tag, tolower(colnames(feature_data)))
    if (any(hits)) {
      mz_col <- colnames(feature_data)[which(hits)[1]]
      break
    }
  }
  rt_col <- NULL
  for (tag in rt_tags) {
    hits <- grepl(tag, tolower(colnames(feature_data)))
    if (any(hits)) {
      rt_col <- colnames(feature_data)[which(hits)[1]]
      break
    }
  }

  if (is.null(mz_col)){
    stop(paste0("No mass to charge ratio column found - should match one of:\n",
                paste(mz_tags, collapse = ", "), " (not case-sensitive)"))
  }
  if (is.null(rt_col)){
    stop(paste0("No retention time column found - should match one of:\n",
                paste(rt_tags, collapse = ", "), " (not case-sensitive)"))
  }

  # Concatenate rounded mass and retention time
  round_mz <- as.numeric(feature_data[, mz_col]) %>% round(digits = 4) %>%
    as.character() %>% gsub("[.]", "_", .)
  round_rt <- as.numeric(feature_data[, rt_col]) %>% round(digits = 4) %>%
    as.character() %>% gsub("[.]", "_", .)
  feature_data$Feature_ID <- paste0(round_mz, "a", round_rt)

  # Add the split columns (usually column, mode and possibly tissue)

  feature_data <- feature_data %>%
    tidyr::unite("Feature_ID", c("Split", "Feature_ID"), remove = FALSE)

  feature_data
}

#' @import methods
#' @importClassesFrom Biobase ExpressionSet
MetaboSet <- setClass("MetaboSet",
                      slots = c(group_col = "character",
                                time_col = "character",
                                subject_col = "character",
                                predicted = "matrix",
                                results = "data.frame"),
                      contains = "ExpressionSet")

setValidity("MetaboSet",
            function(object) {
              if (!is.na(object@group_col) & !object@group_col %in% colnames(object@phenoData@data)) {
                paste0("Column '", object@group_col, "' not found in pheno data")
              } else if (!is.na(object@time_col) & !object@time_col %in% colnames(object@phenoData@data)) {
                paste("Column", object@time_col, "not found in pheno data")
              } else if (!is.na(object@subject_col) & !object@subject_col %in% colnames(object@phenoData@data)) {
                paste("Column", object@subject_col, "not found in pheno data")
              } else {
                TRUE
              }
            })

construct_MetaboSet <- function(assay_data, pheno_data, feature_data,
                                group_col = NA_character_, time_col = NA_character_,
                                subject_col = NA_character_) {

  pheno_data <- Biobase::AnnotatedDataFrame(data=pheno_data)

  # Split the data by the Split column of feature data
  parts <- unique(feature_data$Split)
  obj_list <- list()
  for (part in parts) {
    fd_tmp <- Biobase::AnnotatedDataFrame(data= feature_data[feature_data$Split == part, ])
    ad_tmp <- assay_data[fd_tmp$Feature_ID,]
    obj_list[[part]] <- MetaboSet(exprs = ad_tmp,
                        phenoData = pheno_data,
                        featureData = fd_tmp,
                        group_col = group_col,
                        time_col = time_col,
                        subject_col = subject_col,
                        predicted = matrix(NA_real_, nrow = nrow(ad_tmp),
                                           ncol = ncol(ad_tmp),
                                           dimnames = dimnames(ad_tmp)),
                        results = data.frame(Feature_ID = fd_tmp$Feature_ID,
                                             row.names = rownames(fd_tmp),
                                             stringsAsFactors = FALSE))
  }

  obj_list
}


#' Write results to Excel file
#'
#' Writes all the data in a MetaboSet object to an Excel spreadsheet.
#' The format is similar to the one used to read data in, except that
#' the results from statistics are added to the right.
#'
#' @param object a MetaboSet object
#' @param file path to the file to write
#' @param ... Additional parameters passed to openxlsx::write.xlsx
write_to_excel <- function(object, file, ...) {

  # Bottom part consists of (from left to right):
  # - feature data
  # - abundance values
  # - results from statistics
  bottom <- cbind(fData(object),
                  exprs(object),
                  dplyr::select(results(object), -Feature_ID),
                  results(object)["Feature_ID"])

  # Feature ID column is duplicated on the right for convenience
  colnames(bottom)[ncol(bottom)] <- "Feature_ID2"

  # All columns must be characters to allow combination with the top block
  bottom <- bottom %>%
    dplyr::mutate_all(as.character) %>%
    rbind(colnames(.), .)
  # Top block holds the sample information
  top <- cbind(matrix(colnames(pData(object)), ncol = 1), t(pData(object)))

  # NA blocks to fill the empty space
  empty1 <- matrix(NA_character_, nrow = nrow(top),
                   ncol = ncol(fData(object)) - 1)
  empty2 <- matrix(NA_character_, nrow = nrow(top),
                   ncol = ncol(results(object)))
  top <- cbind(empty1, top, empty2)
  colnames(top) <- colnames(bottom)


  replace_idx <- (ncol(fData(object))+1):(ncol(fData(object)) + ncol(exprs(object)))
  bottom[1, replace_idx] <- top[nrow(top), replace_idx]

  # All combined
  big <- rbind(top[seq_len(nrow(top) - 1), ], bottom)

  openxlsx::write.xlsx(big, file = "test.xlsx", colNames = FALSE, ...)
}


# ------------ Accessors and Replacers -----------------

setGeneric("combined_data", signature = "object",
           function(object) standardGeneric("combined_data"))

#' @importFrom Biobase exprs pData
setMethod("combined_data", c(object = "MetaboSet"),
          function(object) {
            cbind(pData(object), t(exprs(object)))
          })


# stage
setGeneric("stage", signature = "object",
           function(object) standardGeneric("stage"))

setMethod("stage", "MetaboSet",
          function(object) object@stage)

setGeneric("stage<-", signature = "object",
           function(object, value) standardGeneric("stage<-"))

setMethod("stage<-", "MetaboSet",
          function(object, value) {
            object@stage <- value
            if (validObject(object)) {
              return(object)
            }
          })

# group
setGeneric("group_col", signature = "object",
           function(object) standardGeneric("group_col"))

setMethod("group_col", "MetaboSet",
          function(object) object@group_col)

setGeneric("group_col<-", signature = "object",
           function(object, value) standardGeneric("group_col<-"))

setMethod("group_col<-", "MetaboSet",
          function(object, value) {
            object@group_col <- value
            if (validObject(object)) {
              return(object)
            }
          })

# time
setGeneric("time_col", signature = "object",
           function(object) standardGeneric("time_col"))

setMethod("time_col", "MetaboSet",
          function(object) object@time_col)

setGeneric("time_col<-", signature = "object",
           function(object, value) standardGeneric("time_col<-"))

setMethod("time_col<-", "MetaboSet",
          function(object, value) {
            object@time_col <- value
            if (validObject(object)) {
              return(object)
            }
          })

# subject ID
setGeneric("subject_col", signature = "object",
           function(object) standardGeneric("subject_col"))

setMethod("subject_col", "MetaboSet",
          function(object) object@subject_col)

setGeneric("subject_col<-", signature = "object",
           function(object, value) standardGeneric("subject_col<-"))

setMethod("subject_col<-", "MetaboSet",
          function(object, value) {
            object@subject_col <- value
            if (validObject(object)) {
              return(object)
            }
          })

# predicted values from spline regression
setGeneric("predicted", signature = "object",
           function(object) standardGeneric("predicted"))

setMethod("predicted", "MetaboSet",
          function(object) object@predicted)

setGeneric("predicted<-", signature = "object",
           function(object, value) standardGeneric("predicted<-"))

setMethod("predicted<-", "MetaboSet",
          function(object, value) {
            object@predicted <- value
            if (validObject(object)) {
              return(object)
            }
          })


# results from statistical tests
setGeneric("results", signature = "object",
           function(object) standardGeneric("results"))

setMethod("results", "MetaboSet",
          function(object) object@results)

setGeneric("results<-", signature = "object",
           function(object, value) standardGeneric("results<-"))

setMethod("results<-", "MetaboSet",
          function(object, value) {
            object@results <- value
            if (validObject(object)) {
              return(object)
            }
          })













